{"key":"content:en:2.guide:1.concepts:3.rendering.md","generatedAt":"2022-07-24T04:29:04.949Z","mtime":"2022-07-24T04:29:04.920Z","slug":"rendering","title":"Rendering Modes","position":"000200010003","to":"/guide/concepts/rendering","draft":false,"page":true,"language":"en","empty":false,"description":"Both the browser and server can interpret JavaScript code to render Vue.js components into HTML elements. This step is called rendering. Nuxt supports both client-side and universal rendering. The two approaches have pros and cons that we will cover in this section.","body":{"raw":"# Rendering Modes\n\nBoth the browser and server can interpret JavaScript code to render Vue.js components into HTML elements. This step is called **rendering**. Nuxt supports both **client-side** and **universal** rendering. The two approaches have pros and cons that we will cover in this section.\n\n## Client-side only rendering\n\nOut of the box, a traditional Vue.js application is rendered in the browser (or **client**). Then, Vue.js generates HTML elements after the browser downloads and parses all the JavaScript code containing the instructions to create the current interface.\n\n![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/img/concepts/rendering/light/csr.svg){.dark:hidden}\n![Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content](/img/concepts/rendering/dark/csr.svg){.light:hidden}\n\nWhile this technique allows building complex and dynamic UIs with smooth page transitions, it has different pros and cons:\n\n### Pros\n\n- **Development speed**: When working entirely on the client-side, we don't have to worry about the server compatibility of the code, for example, by using browser-only APIs like the `window` object.\n- **Cheaper:** Running a server adds a cost of infrastructure as you would need to run on a platform that supports JavaScript. We can host Client-only applications on any static server with HTML, CSS, and JavaScript files.\n- **Offline:** Because code entirely runs in the browser, it can nicely keep working while the internet is unavailable.\n\n### Cons\n\n- **Performance**: The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience.\n- **Search Engine Optimization**: Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering.\n\n### Examples\n\nClient-side rendering is a good choice for heavily interactive **web applications** that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as **SaaS, back-office applications, or online games**.\n\n## Universal Rendering\n\nWhen the browser requests a URL with universal (client-side + server-side) rendering enabled, the server returns a fully rendered HTML page to the browser. Whether the page has been generated in advance and cached or is rendered on the fly, at some point, Nuxt has run the JavaScript (Vue.js) code in a server environment, producing an HTML document. Users immediately get the content of our application, contrary to client-side rendering. This step is similar to traditional **server-side rendering** performed by PHP or Ruby applications.\n\nTo not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client loads the javascript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence **Universal rendering**) and Vue.js takes control of the document and enables interactivity.\n\nMaking a static page interactive in the browser is called \"Hydration.\"\n\nUniversal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.\n\n![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/light/ssr.svg){.dark:hidden}\n![Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity](/img/concepts/rendering/dark/ssr.svg){.light:hidden}\n\n### Pros\n\n- **Performance**: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated one. At the same time, Nuxt preserves the interactivity of a web application when the hydration process happens.\n- **Search Engine Optimization**: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.\n\n### Cons\n\n- **Development constraints:** Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.\n- **Cost:** A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation.\n\n### Examples\n\nUniversal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: **blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.**\n\n## Summary\n\nClient-side and universal rendering are different strategies to display an interface in a browser.\n\nBy default, Nuxt uses **universal rendering** to provide better user experience and performance, and to optimize search engine indexing, but you can switch rendering modes in [one line of configuration](/guide/directory-structure/nuxt.config#ssr).\n\n## Coming in Nuxt 3\n\nIn most cases, universal rendering as performed in Nuxt 2 offers a good user and developer experience. However, Nuxt 3 takes universal rendering a step further by introducing hybrid rendering and edge-side rendering.\n\n### Hybrid Rendering\n\nHybrid rendering allows different caching rules per route and decides how the Server should respond to a new request on a given URL.\n\nAt the moment, every page (or **route**) of a Nuxt application must use the same rendering mode, client-side or universal. But in various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.\n\n[Read the open RFC discussing implementation and gathering community feedback](https://github.com/nuxt/framework/discussions/560)\n\n### Rendering on CDN edge workers\n\nTraditionally, server-side and universal rendering was only possible using Node.js. Nuxt 3 takes it to another level by directly rendering code in CDN edge workers, reducing latency and costs.\n\nNitro is the new [server engine](/guide/concepts/server-engine) that powers Nuxt 3. It offers cross-platform support for Node.js, Deno, Workers, and more. Nitro's design is platform-agnostic and allows rendering a Nuxt application at the edge, closer to your users, allowing replication and further optimizations.\n","ast":{"type":"root","children":[{"type":"element","tag":"prose-h1","props":{"class":"d-heading-title","id":"rendering-modes"},"children":[{"type":"text","value":"Rendering Modes"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{"class":"d-heading-description"},"children":[{"type":"text","value":"Both the browser and server can interpret JavaScript code to render Vue.js components into HTML elements. This step is called "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"rendering"}]},{"type":"text","value":". Nuxt supports both "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"client-side"}]},{"type":"text","value":" and "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"universal"}]},{"type":"text","value":" rendering. The two approaches have pros and cons that we will cover in this section."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h2","props":{"id":"client-side-only-rendering"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#client-side-only-rendering"},"children":[{"type":"text","value":"Client-side only rendering"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Out of the box, a traditional Vue.js application is rendered in the browser (or "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"client"}]},{"type":"text","value":"). Then, Vue.js generates HTML elements after the browser downloads and parses all the JavaScript code containing the instructions to create the current interface."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"element","tag":"prose-img","props":{"alt":"Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content","className":["dark:hidden"],"src":"/img/concepts/rendering/light/csr.svg"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-img","props":{"alt":"Users have to wait for the browser to download, parse and execute the JavaScript before seeing the page's content","className":["light:hidden"],"src":"/img/concepts/rendering/dark/csr.svg"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"While this technique allows building complex and dynamic UIs with smooth page transitions, it has different pros and cons:"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"pros"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#pros"},"children":[{"type":"text","value":"Pros"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-ul","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Development speed"}]},{"type":"text","value":": When working entirely on the client-side, we don't have to worry about the server compatibility of the code, for example, by using browser-only APIs like the "},{"type":"element","tag":"prose-code-inline","props":{},"children":[{"type":"text","value":"window"}]},{"type":"text","value":" object."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Cheaper:"}]},{"type":"text","value":" Running a server adds a cost of infrastructure as you would need to run on a platform that supports JavaScript. We can host Client-only applications on any static server with HTML, CSS, and JavaScript files."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Offline:"}]},{"type":"text","value":" Because code entirely runs in the browser, it can nicely keep working while the internet is unavailable."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"cons"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#cons"},"children":[{"type":"text","value":"Cons"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-ul","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Performance"}]},{"type":"text","value":": The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Search Engine Optimization"}]},{"type":"text","value":": Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"examples"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#examples"},"children":[{"type":"text","value":"Examples"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Client-side rendering is a good choice for heavily interactive "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"web applications"}]},{"type":"text","value":" that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"SaaS, back-office applications, or online games"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h2","props":{"id":"universal-rendering"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#universal-rendering"},"children":[{"type":"text","value":"Universal Rendering"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"When the browser requests a URL with universal (client-side + server-side) rendering enabled, the server returns a fully rendered HTML page to the browser. Whether the page has been generated in advance and cached or is rendered on the fly, at some point, Nuxt has run the JavaScript (Vue.js) code in a server environment, producing an HTML document. Users immediately get the content of our application, contrary to client-side rendering. This step is similar to traditional "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"server-side rendering"}]},{"type":"text","value":" performed by PHP or Ruby applications."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"To not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client loads the javascript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Universal rendering"}]},{"type":"text","value":") and Vue.js takes control of the document and enables interactivity."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Making a static page interactive in the browser is called \"Hydration.\""}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Universal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"element","tag":"prose-img","props":{"alt":"Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity","className":["dark:hidden"],"src":"/img/concepts/rendering/light/ssr.svg"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-img","props":{"alt":"Users can access the static content when the HTML document is loaded. Hydration then allows page's interactivity","className":["light:hidden"],"src":"/img/concepts/rendering/dark/ssr.svg"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"pros-1"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#pros-1"},"children":[{"type":"text","value":"Pros"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-ul","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Performance"}]},{"type":"text","value":": Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated one. At the same time, Nuxt preserves the interactivity of a web application when the hydration process happens."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Search Engine Optimization"}]},{"type":"text","value":": Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"cons-1"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#cons-1"},"children":[{"type":"text","value":"Cons"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-ul","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Development constraints:"}]},{"type":"text","value":" Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-li","props":{},"children":[{"type":"text","value":"\n"},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"Cost:"}]},{"type":"text","value":" A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation."},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"examples-1"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#examples-1"},"children":[{"type":"text","value":"Examples"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Universal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"blogs, marketing websites, portfolios, e-commerce sites, and marketplaces."}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h2","props":{"id":"summary"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#summary"},"children":[{"type":"text","value":"Summary"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Client-side and universal rendering are different strategies to display an interface in a browser."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"By default, Nuxt uses "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"universal rendering"}]},{"type":"text","value":" to provide better user experience and performance, and to optimize search engine indexing, but you can switch rendering modes in "},{"type":"element","tag":"prose-a","props":{"href":"/guide/directory-structure/nuxt.config#ssr"},"children":[{"type":"text","value":"one line of configuration"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h2","props":{"id":"coming-in-nuxt-3"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#coming-in-nuxt-3"},"children":[{"type":"text","value":"Coming in Nuxt 3"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"In most cases, universal rendering as performed in Nuxt 2 offers a good user and developer experience. However, Nuxt 3 takes universal rendering a step further by introducing hybrid rendering and edge-side rendering."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"hybrid-rendering"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#hybrid-rendering"},"children":[{"type":"text","value":"Hybrid Rendering"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Hybrid rendering allows different caching rules per route and decides how the Server should respond to a new request on a given URL."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"At the moment, every page (or "},{"type":"element","tag":"prose-strong","props":{},"children":[{"type":"text","value":"route"}]},{"type":"text","value":") of a Nuxt application must use the same rendering mode, client-side or universal. But in various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"element","tag":"prose-a","props":{"href":"https://github.com/nuxt/framework/discussions/560","rel":["nofollow","noopener","noreferrer"],"target":"_blank"},"children":[{"type":"text","value":"Read the open RFC discussing implementation and gathering community feedback"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-h3","props":{"id":"rendering-on-cdn-edge-workers"},"children":[{"type":"element","tag":"prose-a","props":{"href":"#rendering-on-cdn-edge-workers"},"children":[{"type":"text","value":"Rendering on CDN edge workers"}]}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Traditionally, server-side and universal rendering was only possible using Node.js. Nuxt 3 takes it to another level by directly rendering code in CDN edge workers, reducing latency and costs."}]},{"type":"text","value":"\n"},{"type":"element","tag":"prose-paragraph","props":{},"children":[{"type":"text","value":"Nitro is the new "},{"type":"element","tag":"prose-a","props":{"href":"/guide/concepts/server-engine"},"children":[{"type":"text","value":"server engine"}]},{"type":"text","value":" that powers Nuxt 3. It offers cross-platform support for Node.js, Deno, Workers, and more. Nitro's design is platform-agnostic and allows rendering a Nuxt application at the edge, closer to your users, allowing replication and further optimizations."}]}]},"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"client-side-only-rendering","depth":2,"text":"Client-side only rendering","children":[{"id":"pros","depth":3,"text":"Pros"},{"id":"cons","depth":3,"text":"Cons"},{"id":"examples","depth":3,"text":"Examples"}]},{"id":"universal-rendering","depth":2,"text":"Universal Rendering","children":[{"id":"pros-1","depth":3,"text":"Pros"},{"id":"cons-1","depth":3,"text":"Cons"},{"id":"examples-1","depth":3,"text":"Examples"}]},{"id":"summary","depth":2,"text":"Summary"},{"id":"coming-in-nuxt-3","depth":2,"text":"Coming in Nuxt 3","children":[{"id":"hybrid-rendering","depth":3,"text":"Hybrid Rendering"},{"id":"rendering-on-cdn-edge-workers","depth":3,"text":"Rendering on CDN edge workers"}]}]}}}